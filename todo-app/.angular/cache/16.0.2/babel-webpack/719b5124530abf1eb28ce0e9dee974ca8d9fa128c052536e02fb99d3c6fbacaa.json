{"ast":null,"code":"import { createEffect, ofType } from '@ngrx/effects';\nimport { loadTodos, loadTodosSuccess, loadTodosFailure, getTodoById } from './todo.actions';\nimport { of, from } from 'rxjs';\nimport { switchMap, map, catchError } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngrx/effects\";\nimport * as i2 from \"src/app/components/todos/todos.service\";\nclass TodoEffects {\n  constructor(actions$, todoService) {\n    this.actions$ = actions$;\n    this.todoService = todoService;\n    // Run this code when a loadTodos action is dispatched\n    this.getTodos$ = createEffect(() => this.actions$.pipe(ofType(loadTodos), switchMap(() =>\n    // Call the getTodos method, convert it to an observable\n    from(this.todoService.getTodos()).pipe(\n    // Take the returned value and return a new success action containing the todos\n    map(todos => loadTodosSuccess({\n      todos: todos\n    })),\n    // Or... if it errors return a new failure action containing the error\n    catchError(error => of(loadTodosFailure({\n      error\n    })))))));\n    // Run this code when a loadTodos action is dispatched\n    this.getTodo$ = createEffect(() => this.actions$.pipe(ofType(getTodoById), switchMap(() =>\n    // Call the getTodos method, convert it to an observable\n    from(this.todoService.getTodos()).pipe(\n    // Take the returned value and return a new success action containing the todos\n    map(todos => loadTodosSuccess({\n      todos: todos\n    })),\n    // Or... if it errors return a new failure action containing the error\n    catchError(error => of(loadTodosFailure({\n      error\n    })))))));\n  }\n}\nTodoEffects.ɵfac = function TodoEffects_Factory(t) {\n  return new (t || TodoEffects)(i0.ɵɵinject(i1.Actions), i0.ɵɵinject(i2.TodoService));\n};\nTodoEffects.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: TodoEffects,\n  factory: TodoEffects.ɵfac\n});\nexport { TodoEffects };","map":{"version":3,"names":["createEffect","ofType","loadTodos","loadTodosSuccess","loadTodosFailure","getTodoById","of","from","switchMap","map","catchError","TodoEffects","constructor","actions$","todoService","getTodos$","pipe","getTodos","todos","error","getTodo$","i0","ɵɵinject","i1","Actions","i2","TodoService","factory","ɵfac"],"sources":["C:\\Angular\\todo-app\\src\\app\\state\\todos\\todo.effects.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\r\nimport {\r\n  loadTodos,\r\n  loadTodosSuccess,\r\n  loadTodosFailure,\r\n  getTodoById,\r\n} from './todo.actions';\r\nimport { of, from } from 'rxjs';\r\nimport { switchMap, map, catchError } from 'rxjs/operators';\r\nimport { Store } from '@ngrx/store';\r\nimport { AppState } from '../app.state';\r\nimport { TodoService } from 'src/app/components/todos/todos.service';\r\n\r\n@Injectable()\r\nexport class TodoEffects {\r\n  constructor(\r\n    private actions$: Actions,\r\n    private todoService: TodoService\r\n  ) {}\r\n\r\n  // Run this code when a loadTodos action is dispatched\r\n  getTodos$ = createEffect(() =>\r\n    this.actions$.pipe(\r\n      ofType(loadTodos),\r\n      switchMap(() =>\r\n        // Call the getTodos method, convert it to an observable\r\n        from(this.todoService.getTodos()).pipe(\r\n          // Take the returned value and return a new success action containing the todos\r\n          map((todos) => loadTodosSuccess({ todos: todos })),\r\n          // Or... if it errors return a new failure action containing the error\r\n          catchError((error) => of(loadTodosFailure({ error })))\r\n        )\r\n      )\r\n    )\r\n  );\r\n\r\n  // Run this code when a loadTodos action is dispatched\r\n  getTodo$ = createEffect(() =>\r\n    this.actions$.pipe(\r\n      ofType(getTodoById),\r\n      switchMap(() =>\r\n        // Call the getTodos method, convert it to an observable\r\n        from(this.todoService.getTodos()).pipe(\r\n          // Take the returned value and return a new success action containing the todos\r\n          map((todos) => loadTodosSuccess({ todos: todos })),\r\n          // Or... if it errors return a new failure action containing the error\r\n          catchError((error) => of(loadTodosFailure({ error })))\r\n        )\r\n      )\r\n    )\r\n  );\r\n\r\n\r\n\r\n  // Run this code when the addTodo or removeTodo action is dispatched\r\n//   saveTodos$ = createEffect(\r\n//     () =>\r\n//       this.actions$.pipe(\r\n//         ofType(addTodo, removeTodo),\r\n//         withLatestFrom(this.store.select(selectAllTodos)),\r\n//         switchMap(([action, todos]) => from(this.todoService.saveTodos(todos)))\r\n//       ),\r\n//     // Most effects dispatch another action, but this one is just a \"fire and forget\" effect\r\n//     { dispatch: false }\r\n//   );\r\n}"],"mappings":"AACA,SAAkBA,YAAY,EAAEC,MAAM,QAAQ,eAAe;AAC7D,SACEC,SAAS,EACTC,gBAAgB,EAChBC,gBAAgB,EAChBC,WAAW,QACN,gBAAgB;AACvB,SAASC,EAAE,EAAEC,IAAI,QAAQ,MAAM;AAC/B,SAASC,SAAS,EAAEC,GAAG,EAAEC,UAAU,QAAQ,gBAAgB;;;;AAK3D,MACaC,WAAW;EACtBC,YACUC,QAAiB,EACjBC,WAAwB;IADxB,KAAAD,QAAQ,GAARA,QAAQ;IACR,KAAAC,WAAW,GAAXA,WAAW;IAGrB;IACA,KAAAC,SAAS,GAAGf,YAAY,CAAC,MACvB,IAAI,CAACa,QAAQ,CAACG,IAAI,CAChBf,MAAM,CAACC,SAAS,CAAC,EACjBM,SAAS,CAAC;IACR;IACAD,IAAI,CAAC,IAAI,CAACO,WAAW,CAACG,QAAQ,EAAE,CAAC,CAACD,IAAI;IACpC;IACAP,GAAG,CAAES,KAAK,IAAKf,gBAAgB,CAAC;MAAEe,KAAK,EAAEA;IAAK,CAAE,CAAC,CAAC;IAClD;IACAR,UAAU,CAAES,KAAK,IAAKb,EAAE,CAACF,gBAAgB,CAAC;MAAEe;IAAK,CAAE,CAAC,CAAC,CAAC,CACvD,CACF,CACF,CACF;IAED;IACA,KAAAC,QAAQ,GAAGpB,YAAY,CAAC,MACtB,IAAI,CAACa,QAAQ,CAACG,IAAI,CAChBf,MAAM,CAACI,WAAW,CAAC,EACnBG,SAAS,CAAC;IACR;IACAD,IAAI,CAAC,IAAI,CAACO,WAAW,CAACG,QAAQ,EAAE,CAAC,CAACD,IAAI;IACpC;IACAP,GAAG,CAAES,KAAK,IAAKf,gBAAgB,CAAC;MAAEe,KAAK,EAAEA;IAAK,CAAE,CAAC,CAAC;IAClD;IACAR,UAAU,CAAES,KAAK,IAAKb,EAAE,CAACF,gBAAgB,CAAC;MAAEe;IAAK,CAAE,CAAC,CAAC,CAAC,CACvD,CACF,CACF,CACF;EAhCE;;AAJQR,WAAW,C;mBAAXA,WAAW,EAAAU,EAAA,CAAAC,QAAA,CAAAC,EAAA,CAAAC,OAAA,GAAAH,EAAA,CAAAC,QAAA,CAAAG,EAAA,CAAAC,WAAA;AAAA;AAAXf,WAAW,C;SAAXA,WAAW;EAAAgB,OAAA,EAAXhB,WAAW,CAAAiB;AAAA;SAAXjB,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}